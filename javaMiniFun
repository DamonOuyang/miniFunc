十大排序
#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##                    快速排序                   ##
######################################~..~########
#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##                    归并排序                   ##
######################################~..~########

package mergesort;


public class MergeSort 
{
    public static void show(int[] data)
    {
        for(int mydata:data)
        {
            System.out.print(mydata+" ");
        }
        System.out.println("");
    }
    
    public static void merge(int[] data,int left,int center,int right)
    {
        // left-center  center+1 right
        int [] tempdata = new int [data.length]; // 保存临时数组，归并
        int mid = center + 1;// 两个数组分割线
        int temppos = left;  // 临时数组的索引，0->
        int templeft = left; // 左边数组的索引
        
        while(left <= center && mid <= right)
        {
            if(data[left] <= data[mid])
            {
                tempdata[temppos] = data[left];
                temppos++;
                left++;
            }
            else
            {
                tempdata[temppos] = data[mid]; // 保存小的数据
                mid++;
                temppos++;
            }
        }
        // 没有结束的链接起来
        while(mid <= right)
        {
            tempdata[temppos] = data[mid];
            temppos++;
            mid++; // 移动
        }
        while(left <= center)
        {
            tempdata[temppos] = data[left];
            temppos++;
            left++;// 移动
        }
        
        while(templeft <= right) // 拷贝回去
        {
            data[templeft] = tempdata[templeft];
            templeft++;
        }
    }
    
    public static void mergesort(int[] data, int left, int right)
    {
        // 左       右
        //0 1 2 3 4 5 6
        if(left >= right)
        {
            return;// 一个元素，
        }
        int center = (left + right)/2;   // 切半
        mergesort(data,left,center);     // 左边
        mergesort(data,center + 1,right);// 右边
        merge(data, left, center, right);// 归并
      
    }
    
    public static void main(String[] args) 
    {
        int [] data = new int[] {89,99,9, 1, 8, 2,3,6,5,4,11};
        mergesort(data,0,data.length-1);
        show(data);
 
    }
}



#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##                    插入排序                   ##
######################################~..~########
package insersort;
public class InserSort 
{
    // 插入排序
    // 主要用于边读文件边排序
    // 插入排序，从前往后（顺序，逆序），往后往前（顺序，逆序），
    // do while, while for ,递归
    public static void main1(String[] args)
    {
        // int [] myint = new int [] {1,9,2,8,3,7,4,6,5};
        int [] myints = new int[]{1,5,9,19,23,28,20};
        int pos = 0;// 要插入的位置
        int insertdata = myints[myints.length - 1];// 要插入
        for(int i=0;i<myints.length - 1;i++)
        {
            if(insertdata > myints[i] && insertdata<=myints[i+1])// 找到位置
            {
                pos = i;// 找到位置并保存位置
                for(int j=myints.length - 2;j>=i+1;j--)
                {
                    myints[j+1] = myints[j];// 往后移动
                }
                myints[i+1] = insertdata; // 插入数据
            }
        }
        
        for(int mydata:myints)
        {
            System.out.print(mydata+" ");
        }
    }
    public static void main2(String[] args) 
    {
        int [] myints = new int [] {1,9,2,8,3,7,4,6,5};
        for(int i=1;i<myints.length;i++)
        {
            int nowdata = myints[i];// 插入的数据
            int k = 0; //pos
            for(k=i-1;k>=0 && myints[k]>nowdata;k--)// 寻找合适的位置
            {
                myints[k+1] = myints[k];// 数据移动
            }
            myints[k+1] = nowdata; // 插入数据
            
            // 显示
            for(int mydata:myints)
            {
                System.out.print(mydata+" ");
            }
            System.out.println("");
        }
        
        for(int mydata:myints)
        {
            System.out.print(mydata+" ");
        }
     
    }
    
    // 二分查找 插入排序
    public static void main(String[] args)
    {
        int [] myints = new int[]{1,9,2,8,3,7,4,6,5};
        for(int i=1;i<myints.length;i++)
        {
            if(myints[i]<myints[i-1])// 插入前提
            {
                int tempinsert = myints[i];
                int low = 0;
                int high = i - 1;// 二分查找的上限，下限
                while(low <= high) //处理重合
                {
                    int mid = (low+high)/2;
                    if(myints[mid]<tempinsert)
                    {
                        low = mid + 1;
                    }
                    else
                    {
                        high = mid - 1;
                    }
                }
                // low
                for(int j=i;j>low;j--)
                {
                    myints[j] = myints[j-1];
                }
                myints[low] = tempinsert;// 插入一个数据
            }
            
            for(int mydata:myints)
            {
                System.out.print(mydata+" ");
            }
            System.out.println("");
            
        }
        for(int mydata:myints)
        {
            System.out.print(mydata+" ");
        }
    }
    
}



#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##                    快速排序                   ##
######################################~..~########
package csdn_quicksort;

public class Csdn_QuickSort 
{
    // 4   9 8 7  1 2 3 6;
    // 1 2 3  4  9 8 7 6 ; // 左边小于中间，中间小于右边
    // 左              右
    // 4
    
    // 4   9 8 7  1 2 3 6; // 找最左边大于第一个数,找最右边小于第一个数
    // 4   3 8 7  1 2 9 6; // 交换
    // 4   3 2 1  7 8 9 6; // 如此循环交换后
    // 1   3 2 4  7 8 9 6;
    public static void show(int [] ints)
    {
        for(int i:ints)
        {
            System.out.print(i+" ");
        }
        System.out.print("\n");
    }
    public static int getmid(int [] ints,int low, int high)
    {
        int temp = ints[low];
        while(low<high)
        {
            while(low<high && ints[high] > temp)
            {
                high--;
            }
            ints[low] = ints[high];
            while(low<high && ints[low] < temp)
            {
                low++;
            }
            ints[high] = ints[low];     
        }
        ints[low] = temp;
        show(ints);

        return low;
        
    }
    
    public static void Qsort(int [] ints,int low, int high)
    {
        if(ints.length <= 1 || ints == null)
        {
            return;
        }
        
        if(low<high)
        {
            int mid = getmid(ints,low,high);
            Qsort(ints,mid+1,high);
            Qsort(ints,low,mid-1);
        }
        
    }
    public static void main(String [] args)
    {
        int [] ints = {4 ,  9, 8, 7,  1, 2, 3, 6};
        show(ints);
        Qsort(ints,0,ints.length - 1);
        show(ints);
        
    }
    
    
    
    

    
}
/*
    public static void show(int [] inst)
    {
        for(int i:inst)
        {
            System.out.print(i + " ");
        }
        System.out.print("\n");
    }
    
    public static int getmid(int [] ints, int low, int high)
    {
        int temp = ints[low];
        while(low < high)
        {
            // 从右往左
            while(low < high && ints[high]>temp)// 最左边大于第一个
            {
                high--;
            }
            ints[low] = ints[high];
            // 从左往右
            while( low < high && ints[low]<temp )// 最右边小于第一个
            {
                low++;
            }
            ints[high] = ints[low];
        }
        ints[low] = temp;
        show(ints);
        return low;
    }
    public static void Qsort(int [] ints,int low,int high)
    {
        if(ints.length <= 1 || ints==null)
        {
            return;
        }
        if(low<high)
        {
            int mid = getmid(ints, low, high);
            Qsort(ints, low, mid-1);// 前段
            Qsort(ints, mid+1, high); 
        }
 
    }

    public static void main(String[] args)
    {
        int [] ints ={4,   9, 8,  7, 1, 2, 3, 6};
        show(ints);
        Qsort(ints,0,ints.length-1);
        show(ints);
        
    }
*/

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##             拉格朗日插值查找                   ##
######################################~..~########
package binsearch;

public class BinSearch 
{
    //1024   10次
    //1024
    //512  512
    //256  256
    //128 128
    //2
    //1  1
    //   1  2   3  4 5  6 7 8 9 10 
    //            5>j  j>3;
    public static int binsearch(int []arr,int findnum)
    {
        int max=arr.length-1;
        int min=0;
        //int mid=(max+min)/2;
        int mid=min+ (max-min)/2;
      //  int mid=min+ (max-min)*(1/2);
        
        int times=0;
        while(arr[mid]!=findnum)
        {
            times++;
            if(findnum>arr[mid])
            {
                min=mid+1;
            }
            else if(findnum< arr[mid])
            {
                max=mid-1;
            }
            mid=(max+min)/2;
            if(max<min)
            {
                return -1;
            }
            
        }
      System.out.println( times+"次");
        return mid;
        
    }
      public static int binsearchX(int []arr,int findnum)
    {
        int max=arr.length-1;
        int min=0;
        //int mid=(max+min)/2;
       // int mid=min+ (max-min)/2;
      //  int mid=min+ (max-min)*(1/2);
      //  int mid=min+ (max-min)*( mid-min/max- min      );//二分查找法的比例
        int mid =    (int) (min+ (max-min)*( (findnum-arr[min])*1.0/(arr[max]- arr[min]  )    ));
        int times=1;
        while(arr[mid]!=findnum)
        {
            times++;
            if(findnum>arr[mid])
            {
                min=mid+1;
            }
            else if(findnum< arr[mid])
            {
                max=mid-1;
            }
            mid=(max+min)/2;
            if(max<min)
            {
                return -1;
            }
            
        }
      System.out.println( times+"次");
        return mid;
        
    }
    
    public static void main(String[] args) 
    {
         int [] myint=new int [1024];
         for(int i=1;i<=1024;i++)
         {
             myint[i-1]=i;
         }
        System.out.println( binsearchX(myint, 369));
        //1024  2^10
    }
    
}

//int mid = (min + max)/2;
//int mid = min + (max - min)/2;
//int mid = min + (max - min)/(1/2);
//int mid = min + (max - min)/((mid - min )/ (max - min));
//int mid = min + (max - min) / ( ( (findnum - arr[min])*1.0)/(arr[max] - arr[min])      );


#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##                    二分查找                   ##
######################################~..~########
package binsearch;

public class BinSearch 
{
    public static int binSeach(int [] arr,int findnum)
    {
        int min = 0;
        int max = arr.length - 1;
        int mid = (min + max) / 2;
        int times = 1;
        while(arr[mid] != findnum)
        {
            if( findnum  > arr[mid])
            {
                min = mid + 1;
            }
            else if ( findnum < arr[mid])
            {
                max = mid - 1;
            }
            mid = (max + mid)/2;
            
            if(max < min)
            {
                return -1;
            }
            times ++;
        }
        System.out.println(times + " 次");
        return mid;
    }

    public static void main(String[] args) 
    {
        int [] myint = new int[1024];
        for(int i=1;i<=1024;i++)
        {
            myint[i-1] = i;
        }
        int index = binSeach(myint,14);
        System.out.println(index);
    }  
}
