#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##                6. 重用全局变量               ##
######################################~..~########
# !/usr/bin/python  
# coding:utf-8  
# -*- coding:utf-8 -*-

def my_func():
    print(var) # 我可以先调用一个未定义的变量
var = "global" # 后赋值
my_func() # 反正只要调用函数时候变量被定义了就可以了

def my_func1():
    var = "locally changed"
var = "global"
my_func()
print(var)

def my_func2():
    global var # 这个时候得加全局了
    print(var) # 这样就能正常使用
    var = "locally changed" # 全局变量会被改变

var = "global"

my_func2()
print(var) # 但是使用了 global 就改变了全局变量

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##    5. IndexError–列表取值超出了他的索引数    ##
######################################~..~########
# !/usr/bin/python  
# coding:utf-8  
# -*- coding:utf-8 -*-

my_list = [1, 2, 3, 4, 5]
# my_list[5] # 根本没有这个元素
my_list[5:] # 但是可以这样， 一定要注意, 用好了是trick,用错了就是坑啊

In [55]: my_list = [1, 2, 3, 4, 5]
 
In [56]: my_list[5] # 根本没有这个元素
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-56-037d00de8360> in <module>()
----> 1 my_list[5]
 
IndexError: list index out of range # 抛异常了
 
In [57]: my_list[5:] # 但是可以这样， 一定要注意, 用好了是trick,用错了就是坑啊
Out[57]: []
#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##          4. 在循环中修改列表项               ##
######################################~..~########
# !/usr/bin/python  
# coding:utf-8  
# -*- coding:utf-8 -*-
a = [1, 2, 3, 4, 5]
for i in a :
    if not i % 2:
        a.remove(i)
print(a) #  [1, 3, 5] 没有问题

b = [ 2, 4, 5, 6]
for i in b:
    if not  i % 2:
        b.remove(i)
print(b)#[4, 5] ????
# 思考一下,为什么 – 是因为你对列表的remove,影响了它的index
c = [2,4,5,6,7,8]
for index, item in enumerate(c):
    print(index, item)
    if not item % 2:
        c.remove(item)
#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##     3. lambda在闭包中会保存局部变量          ##
######################################~..~########
# !/usr/bin/python  
# coding:utf-8  
# -*- coding:utf-8 -*-
# 
# my_list = [ lambda: i for i in range(5)]
# for l in my_list:
#     print(l())
# 4
# 4
# 4
# 4
# 4
# print("-------------------")
# my_list = [ lambda x=i:x for i in range(5)] # 看我给每个lambda表达式附了默认值
# for l in my_list:
#     print(l())
# 0
# 1
# 2
# 3
# 4

def groupby(items, size):
    print([iter(items)]*3)
    print([lambda x=i: x for i in range(5)])
    return zip(*[iter(items)]*size)
#
print( *(groupby(range(9), 3)) ) # 拆包

# (0, 1, 2) (3, 4, 5) (6, 7, 8)

# [<range_iterator object at 0x004F4D10>, <range_iterator object at 0x004F4D10>, <range_iterator object at 0x004F4D10>]
# [<function groupby.<locals>.<listcomp>.<lambda> at 0x0259E930>, <function groupby.<locals>.<listcomp>.<lambda> at 0x0259E8E8>, <function groupby.<locals>.<listcomp>.<lambda> at 0x0259E9C0>, <function groupby.<locals>.<listcomp>.<lambda> at 0x0259EA08>, <function groupby.<locals>.<listcomp>.<lambda> at 0x0259EA50>]
# (0, 1, 2) (3, 4, 5) (6, 7, 8)

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##      2. 生成器不保留迭代过后的结果           ##
######################################~..~########
# !/usr/bin/python  
# coding:utf-8  
# coding=utf-8  
# -*- coding:utf-8 -*-

gen = (i for i in range(5))
print(2 in gen) # True
#print(2 in gen) # False

print(3 in gen)
print(3 in gen)
print(1 in gen)# 1 为什么不在gen里面了? 因为调用1->2,这个时候1已经不在迭代器里面了,被按需生成过了
print("----------------------------------")
gen = (i for i in range(5))
a_list = list(gen) # 可以转化成列表，当然a_tuple = tuple(gen) 也可以

print(2 in a_list)# Ture
print(3 in a_list)# Ture
print(1 in a_list)# Ture 就算循环过，值还在

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##   1. 不要使用可变对象作为函数默认值          ##
######################################~..~########
# !/usr/bin/python  
# coding:utf-8  
# coding=utf-8  
# -*- coding:utf-8 -*-

# 第一个例子
def append_to_list(value, def_list=[]):
    def_list.append(value)
    return def_list

my_list = append_to_list(1)
print(my_list)

my_other_list = append_to_list(2)
print(my_other_list) # [1,2] 看到了吧，其实我们本来只想生成[2] 但是却把第一次运行的效果页带了进来

# 第二个例子
import time
def report_arg(my_default=time.time()):
    print(my_default)

report_arg() # 第一次执行
time.sleep(2)# 隔了2秒
report_arg()# 时间没有变

代码可以改为如下：
def append_to_list(element,to=None):
    if to is None:
        to = []
    to.append(element)
    print(to)
    return to

append_to_list(1)# [1] 
append_to_list(2)# [2]

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##                  py面向对象                  ##
######################################~..~########
# !/usr/bin/python  
class Digua(object):

    def __init__(self):
        self.cookString = "生的"
        self.level = 0
        self.condiments = []

    def __str__(self):
        return "烤地瓜的时间：%d%s, 已经有的作料是%s"%(self.level,self.cookString,str(self.condiments))

    def kaodigua(self,time):
        self.level += time
        if self.level < 3:
            self.cookString = "生的"
        elif self.level >=3 and self.level < 5:
            self.cookString = "半生不熟"
        elif self.level > 5:
            self.cookString = "熟了"

    def addCondiments(self, c):
        self.condiments += c

d = Digua()
d.kaodigua(1)
d.addCondiments("大蒜")
print(d)

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##            指定编码的集中方式                ##
######################################~..~########
# !/usr/bin/python  

# coding=<encoding name>  
# -*- coding: <encoding name> -*- 
# vim: set fileencoding=<encoding name> :  

如下：
# coding:utf-8  
# coding=utf-8  
# -*- coding:utf-8 -*-

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##              批量修改文件名称                ##
######################################~..~########
# 
# coding:utf-8  

import os
folder_name = input("请输入你的文件夹名称:")
file_names = os.listdir(folder_name)

for name in file_names:
    print(name)
    old_file_name = folder_name + "/" + name
    new_file_name = folder_name + "/" + "[xxx]" + name
    os.rename(old_file_name,new_file_name)

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##          文件处理 大文件处理流程             ##
######################################~..~########
# 
# coding:utf-8  

old_file_name = input("请输入要复制的文件名：")
old_file = open(old_file_name,"r")

new_file_name = old_file_name[:old_file_name.rfind(".")] + "[copy]" + old_file_name[old_file_name.rfind("."):]
new_file = open(new_file_name,"w")

while True:
    content = old_file.read(1024)
    if len(content) == 0:
        break
    count = new_file.write(content)

old_file.close()
new_file.close()

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##    函数参数python都传引用注意可变和不可变    ##
######################################~..~########
# 
# coding:utf-8  
# a = 100
a = [100]
def test(num):
    # num += num# 分两步：1 先去看num是不是可变类型，如果是直接修改num,也就是a的地址内容 2 不是可变类型，就生成一个临时变量保存
    num = num + num# 只有一步：num + num 再生成一个临时变量保存
    print(num)

test(a)
print(a)

#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##  不定长参数 *args **kwargs    ##
#######################~..~########
# 
# coding:utf-8  
def test(a, b, c=33,*args, **kwargs):
    print(a)
    print(b)
    print(c)
    print(args)
    print(kwargs)

# test(11, 22, 33, 44, 55, 66, 77, task=99, done=89)
A = (44, 55, 66)
B = {"name":"laowang","age":18}
test(11, 22, 33, *A, **B)
# test(11,22,33,A,B)


#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##      dict [key,value]         ##
#######################~..~########
# 
# coding:utf-8  

infor = {"name":"laowang",100:"haha",3.14:"heihei",(11,22):"sfalsfs",[11,22]:"enen"}

Traceback (most recent call last):
  File "F:/Python Learning/AiTest/01with.py", line 315, in <module>
    infor = {"name":"laowang",100:"haha",3.14:"heihei",(11,22):"sfalsfs",[11,22]:"enen"}
TypeError: unhashable type: 'list'

#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##       machine-learning          ##
#######################~..~########
# 
# coding:utf-8  

from sklearn.neighbors import KNeighborsClassifier # 分类器
knn=KNeighborsClassifier(n_neighbors=2) # 2个核心，2个类
x=[
    [180, 180, 180],
    [181, 182, 183],
    [160, 20, 100],
    [162, 21, 103],
   ]
y = ["高富帅","高富帅","屌丝","屌丝"]
knn.fit(x,y) # 训练数据模型

print("书生是",knn.predict([[181,187,192]]))
print("52小牛是",knn.predict([[153,17,92]]))
print("追梦少年是",knn.predict([[165,27,122]]))
print("yincheng是",knn.predict([[169,17,130]]))
print("越南邻国宰相",knn.predict([[178,230,170]]))

#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##       quick_sort                  ##
#######################~..~########
# 
# coding:utf-8

def insert_sort(alist):
    """插入排序"""
    n = len(alist)
    # 从右边的无序序列中取出多少个元素执行这样的过程
    for j in range(1, n):
        # j = [1, 2, 3, n-1]
        # i 代表内层循环起始值
        i = j
        # 执行从右边的无序序列中取出第一个元素，即i位置的元素，然后将其插入到前面的正确位置中
        while i > 0:
            if alist[i] < alist[i-1]:
                alist[i], alist[i-1] = alist[i-1], alist[i]
                i -= 1
            else:
                break

if __name__ == "__main__":
    li = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print(li)
    insert_sort(li)
    print(li)
     
#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##       quick_sort                  ##
#######################~..~########
#  
# coding:utf-8

def quick_sort(alist, first, last):
    """快速排序"""
    if first >= last:
        return
    mid_value = alist[first]
    low = first
    high = last
    while low < high:
        # high 左移
        while low < high and alist[high] >= mid_value:
            high -= 1
        alist[low] = alist[high]

        while low <high and alist[low] < mid_value:
            low += 1
        alist[high] = alist[low]
    # 从循环退出时，low==high
    alist[low] = mid_value

    # 对low左边的列表执行快速排序
    quick_sort(alist, first, low-1)

    # 对low右边的列表排序
    quick_sort(alist, low+1, last)

if __name__ == "__main__":
    li = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print(li)
    quick_sort(li, 0, len(li)-1)
    print(li)

#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##       BSTree                  ##
#######################~..~########
#    
# coding:utf-8

class Node(object):
    """"""
    def __init__(self, item):
        self.elem = item
        self.lchild = None
        self.rchild = None

class Tree(object):
    """二叉树"""
    def __init__(self):
        self.root = None

    def add(self, item):
        node = Node(item)
        if self.root is None:
            self.root = node
            return
        queue = [self.root]
        while queue:
            cur_node = queue.pop(0)
            if cur_node.lchild is None:
                cur_node.lchild = node
                return
            else:
                queue.append(cur_node.lchild)
            if cur_node.rchild is None:
                cur_node.rchild = node
                return
            else:
                queue.append(cur_node.rchild)

    def breadth_travel(self):
        """广度遍历"""
        if self.root is None:
            return
        queue = [self.root]
        while queue:
            cur_node = queue.pop(0)
            print(cur_node.elem, end=" ")
            if cur_node.lchild is not None:
                queue.append(cur_node.lchild)
            if cur_node.rchild is not None:
                queue.append(cur_node.rchild)

    def preorder(self, node):
        """先序遍历"""
        if node is None:
            return
        print(node.elem, end=" ")
        self.preorder(node.lchild)
        self.preorder(node.rchild)

    def inorder(self, node):
        """中序遍历"""
        if node is None:
            return
        self.inorder(node.lchild)
        print(node.elem, end=" ")
        self.inorder(node.rchild)

    def postorder(self, node):
        """后序遍历"""
        if node is None:
            return
        self.postorder(node.lchild)
        self.postorder(node.rchild)
        print(node.elem, end=" ")


if __name__ == "__main__":
    tree = Tree()
    tree.add(0)
    tree.add(1)
    tree.add(2)
    tree.add(3)
    tree.add(4)
    tree.add(5)
    tree.add(6)
    tree.add(7)
    tree.add(8)
    tree.add(9)
    tree.breadth_travel()
    print(" ")
    tree.preorder(tree.root)
    print(" ")
    tree.inorder(tree.root)
    print(" ")
    tree.postorder(tree.root)
    print(" ")

#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##       Regular expression      ##
#######################~..~########
#    
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#Filename:MiniFunc.py
 
# -*- coding: utf-8 -*-

import types
import json                             
import re
def paramVerification(param):
	# param that including ONLY [a-z,A-Z,0-9,_] is legal.
	reStr = r'^\w+$'
	m = re.match(reStr, param)
	if m:
		return True
	else:
		return False
	
def paramSplit(reString, paramString):
	# return a param LIST, split by reString
	return re.split(reString, paramString)

#                      /\   /\     
#                 ╭╮(╯▽╰)╭╮ 
##################^^^#########^^^##
##      Encrypto Utilities       ##
#######################~..~########
#                                  
import hashlib
def md5(string):
	if type(string) is types.StringType:
		m = hashlib.md5()
		m.update(string)
		return m.hexdigest()
	else:
		return ''

#                      /\  /\     
#                    ψ(╰_╯)σ 
###################################
##         Log Utilities         ##
#######################~..~########
#                                  
import re
import logging  
def setLogConfig():
	logging.basicConfig(level=logging.WARNING,  
		filename='./Log/log.txt',  
		filemode='w',  
		format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')
	pass
	
def Log(level, message):
	try:
		m = re.match(r'^warning$|^error$', level)
		if m:
			func = getattr(logging, level)
			func(message+'\n')
		else:
			print 'log level wrong!'
			logging.error('log level wrong: %s\n' %message)
	except Exception as e:
		logging.error('log exception: %s\n' %e.message)

#                     /\   /\      
#                 ╭(#￣▽￣#)╮ 
##################^^^#######^^^####
##          Time handler         ##
#######################~..~########
#                                  
import time
def getCurrentTime():
	# Time format: 20170301162559
	return time.strftime("%Y%m%d%H%M%S", time.localtime())

def getCurrentMKTime():
	# return time format: Sat Mar 28 22:24:24 2016
	return time.strftime("%a %b %d %H:%M:%S %Y", time.localtime())

def transStringToTime(timeString):
	# Time string format: Sat Mar 28 22:24:24 2016
	# return 1459175064.0
	return time.mktime(time.strptime(timeString,"%a %b %d %H:%M:%S %Y"))

#        (\   /)                   
#     ﹏(￣▽￣) ﹏                 
#####^^^########^^^################
##          QR  handler          ##
##########~..~#####################
#                                  
import qrcode
from PIL import Image
def make_QR(strQR):
	qr = qrcode.QRCode(  
		version=4,  
		error_correction=qrcode.constants.ERROR_CORRECT_L,  
		box_size=10,  
		border=4,  
	)  

	qr.add_data(str(strQR))  
	qr.make(fit=True)  
	img = qr.make_image()
	return img

#        (\   /)                   
#     ﹏(0▽ 0 ) ﹏                 
#####^^^########^^^################
##        Queue  handler         ##
##########~..~#####################
#                                  
import Queue
queue = Queue.Queue()
def addItem(item):
	queue.put(item)
	
def getItem():
	try:
		item = queue.get(timeout = 2)
		return item
	except Queue.Empty:
		print 'queue empty'
		return None
	
def getQSize():
	return queue.qsize()
	
def clearQueue():
	queue.queue.clear()

##############################################################################
# Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ 
#   Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ   
##############################################################################

if '__main__' == __name__:
	while(True):
		cType = raw_input("Input:")
		if cType == 'a':
			addItem("A")
		elif cType == 'g':
			print getItem()
		elif cType == 's':
			print getQSize()
		elif cType == 'c':
			clearQueue()
		else:
			break;
		pass






















