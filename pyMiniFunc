#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##   1. 不要使用可变对象作为函数默认值          ##
######################################~..~########
# !/usr/bin/python  
# coding:utf-8  
# coding=utf-8  
# -*- coding:utf-8 -*-

# 第一个例子
def append_to_list(value, def_list=[]):
    def_list.append(value)
    return def_list

my_list = append_to_list(1)
print(my_list)

my_other_list = append_to_list(2)
print(my_other_list) # [1,2] 看到了吧，其实我们本来只想生成[2] 但是却把第一次运行的效果页带了进来

# 第二个例子
import time
def report_arg(my_default=time.time()):
    print(my_default)

report_arg() # 第一次执行
time.sleep(2)# 隔了2秒
report_arg()# 时间没有变

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##            指定编码的集中方式                ##
######################################~..~########
# !/usr/bin/python  

# coding=<encoding name>  
# -*- coding: <encoding name> -*- 
# vim: set fileencoding=<encoding name> :  

如下：
# coding:utf-8  
# coding=utf-8  
# -*- coding:utf-8 -*-

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##              批量修改文件名称                ##
######################################~..~########
# 
# coding:utf-8  

import os
folder_name = input("请输入你的文件夹名称:")
file_names = os.listdir(folder_name)

for name in file_names:
    print(name)
    old_file_name = folder_name + "/" + name
    new_file_name = folder_name + "/" + "[xxx]" + name
    os.rename(old_file_name,new_file_name)

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##          文件处理 大文件处理流程             ##
######################################~..~########
# 
# coding:utf-8  

old_file_name = input("请输入要复制的文件名：")
old_file = open(old_file_name,"r")

new_file_name = old_file_name[:old_file_name.rfind(".")] + "[copy]" + old_file_name[old_file_name.rfind("."):]
new_file = open(new_file_name,"w")

while True:
    content = old_file.read(1024)
    if len(content) == 0:
        break
    count = new_file.write(content)

old_file.close()
new_file.close()

#                      /\  /\      
#                    ( @ . @ )     
#################################^^^#########^^^##
##    函数参数python都传引用注意可变和不可变    ##
######################################~..~########
# 
# coding:utf-8  
# a = 100
a = [100]
def test(num):
    # num += num# 分两步：1 先去看num是不是可变类型，如果是直接修改num,也就是a的地址内容 2 不是可变类型，就生成一个临时变量保存
    num = num + num# 只有一步：num + num 再生成一个临时变量保存
    print(num)

test(a)
print(a)

#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##  不定长参数 *args **kwargs    ##
#######################~..~########
# 
# coding:utf-8  
def test(a, b, c=33,*args, **kwargs):
    print(a)
    print(b)
    print(c)
    print(args)
    print(kwargs)

# test(11, 22, 33, 44, 55, 66, 77, task=99, done=89)
A = (44, 55, 66)
B = {"name":"laowang","age":18}
test(11, 22, 33, *A, **B)
# test(11,22,33,A,B)


#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##      dict [key,value]         ##
#######################~..~########
# 
# coding:utf-8  

infor = {"name":"laowang",100:"haha",3.14:"heihei",(11,22):"sfalsfs",[11,22]:"enen"}

Traceback (most recent call last):
  File "F:/Python Learning/AiTest/01with.py", line 315, in <module>
    infor = {"name":"laowang",100:"haha",3.14:"heihei",(11,22):"sfalsfs",[11,22]:"enen"}
TypeError: unhashable type: 'list'

#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##       machine-learning          ##
#######################~..~########
# 
# coding:utf-8  

from sklearn.neighbors import KNeighborsClassifier # 分类器
knn=KNeighborsClassifier(n_neighbors=2) # 2个核心，2个类
x=[
    [180, 180, 180],
    [181, 182, 183],
    [160, 20, 100],
    [162, 21, 103],
   ]
y = ["高富帅","高富帅","屌丝","屌丝"]
knn.fit(x,y) # 训练数据模型

print("书生是",knn.predict([[181,187,192]]))
print("52小牛是",knn.predict([[153,17,92]]))
print("追梦少年是",knn.predict([[165,27,122]]))
print("yincheng是",knn.predict([[169,17,130]]))
print("越南邻国宰相",knn.predict([[178,230,170]]))

#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##       quick_sort                  ##
#######################~..~########
# 
# coding:utf-8

def insert_sort(alist):
    """插入排序"""
    n = len(alist)
    # 从右边的无序序列中取出多少个元素执行这样的过程
    for j in range(1, n):
        # j = [1, 2, 3, n-1]
        # i 代表内层循环起始值
        i = j
        # 执行从右边的无序序列中取出第一个元素，即i位置的元素，然后将其插入到前面的正确位置中
        while i > 0:
            if alist[i] < alist[i-1]:
                alist[i], alist[i-1] = alist[i-1], alist[i]
                i -= 1
            else:
                break

if __name__ == "__main__":
    li = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print(li)
    insert_sort(li)
    print(li)
     
#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##       quick_sort                  ##
#######################~..~########
#  
# coding:utf-8

def quick_sort(alist, first, last):
    """快速排序"""
    if first >= last:
        return
    mid_value = alist[first]
    low = first
    high = last
    while low < high:
        # high 左移
        while low < high and alist[high] >= mid_value:
            high -= 1
        alist[low] = alist[high]

        while low <high and alist[low] < mid_value:
            low += 1
        alist[high] = alist[low]
    # 从循环退出时，low==high
    alist[low] = mid_value

    # 对low左边的列表执行快速排序
    quick_sort(alist, first, low-1)

    # 对low右边的列表排序
    quick_sort(alist, low+1, last)

if __name__ == "__main__":
    li = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print(li)
    quick_sort(li, 0, len(li)-1)
    print(li)

#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##       BSTree                  ##
#######################~..~########
#    
# coding:utf-8

class Node(object):
    """"""
    def __init__(self, item):
        self.elem = item
        self.lchild = None
        self.rchild = None

class Tree(object):
    """二叉树"""
    def __init__(self):
        self.root = None

    def add(self, item):
        node = Node(item)
        if self.root is None:
            self.root = node
            return
        queue = [self.root]
        while queue:
            cur_node = queue.pop(0)
            if cur_node.lchild is None:
                cur_node.lchild = node
                return
            else:
                queue.append(cur_node.lchild)
            if cur_node.rchild is None:
                cur_node.rchild = node
                return
            else:
                queue.append(cur_node.rchild)

    def breadth_travel(self):
        """广度遍历"""
        if self.root is None:
            return
        queue = [self.root]
        while queue:
            cur_node = queue.pop(0)
            print(cur_node.elem, end=" ")
            if cur_node.lchild is not None:
                queue.append(cur_node.lchild)
            if cur_node.rchild is not None:
                queue.append(cur_node.rchild)

    def preorder(self, node):
        """先序遍历"""
        if node is None:
            return
        print(node.elem, end=" ")
        self.preorder(node.lchild)
        self.preorder(node.rchild)

    def inorder(self, node):
        """中序遍历"""
        if node is None:
            return
        self.inorder(node.lchild)
        print(node.elem, end=" ")
        self.inorder(node.rchild)

    def postorder(self, node):
        """后序遍历"""
        if node is None:
            return
        self.postorder(node.lchild)
        self.postorder(node.rchild)
        print(node.elem, end=" ")


if __name__ == "__main__":
    tree = Tree()
    tree.add(0)
    tree.add(1)
    tree.add(2)
    tree.add(3)
    tree.add(4)
    tree.add(5)
    tree.add(6)
    tree.add(7)
    tree.add(8)
    tree.add(9)
    tree.breadth_travel()
    print(" ")
    tree.preorder(tree.root)
    print(" ")
    tree.inorder(tree.root)
    print(" ")
    tree.postorder(tree.root)
    print(" ")

#                      /\  /\      
#                    ( @ . @ )     
##################^^^#########^^^##
##       Regular expression      ##
#######################~..~########
#    
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#Filename:MiniFunc.py
 
# -*- coding: utf-8 -*-

import types
import json                             
import re
def paramVerification(param):
	# param that including ONLY [a-z,A-Z,0-9,_] is legal.
	reStr = r'^\w+$'
	m = re.match(reStr, param)
	if m:
		return True
	else:
		return False
	
def paramSplit(reString, paramString):
	# return a param LIST, split by reString
	return re.split(reString, paramString)

#                      /\   /\     
#                 ╭╮(╯▽╰)╭╮ 
##################^^^#########^^^##
##      Encrypto Utilities       ##
#######################~..~########
#                                  
import hashlib
def md5(string):
	if type(string) is types.StringType:
		m = hashlib.md5()
		m.update(string)
		return m.hexdigest()
	else:
		return ''

#                      /\  /\     
#                    ψ(╰_╯)σ 
###################################
##         Log Utilities         ##
#######################~..~########
#                                  
import re
import logging  
def setLogConfig():
	logging.basicConfig(level=logging.WARNING,  
		filename='./Log/log.txt',  
		filemode='w',  
		format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')
	pass
	
def Log(level, message):
	try:
		m = re.match(r'^warning$|^error$', level)
		if m:
			func = getattr(logging, level)
			func(message+'\n')
		else:
			print 'log level wrong!'
			logging.error('log level wrong: %s\n' %message)
	except Exception as e:
		logging.error('log exception: %s\n' %e.message)

#                     /\   /\      
#                 ╭(#￣▽￣#)╮ 
##################^^^#######^^^####
##          Time handler         ##
#######################~..~########
#                                  
import time
def getCurrentTime():
	# Time format: 20170301162559
	return time.strftime("%Y%m%d%H%M%S", time.localtime())

def getCurrentMKTime():
	# return time format: Sat Mar 28 22:24:24 2016
	return time.strftime("%a %b %d %H:%M:%S %Y", time.localtime())

def transStringToTime(timeString):
	# Time string format: Sat Mar 28 22:24:24 2016
	# return 1459175064.0
	return time.mktime(time.strptime(timeString,"%a %b %d %H:%M:%S %Y"))

#        (\   /)                   
#     ﹏(￣▽￣) ﹏                 
#####^^^########^^^################
##          QR  handler          ##
##########~..~#####################
#                                  
import qrcode
from PIL import Image
def make_QR(strQR):
	qr = qrcode.QRCode(  
		version=4,  
		error_correction=qrcode.constants.ERROR_CORRECT_L,  
		box_size=10,  
		border=4,  
	)  

	qr.add_data(str(strQR))  
	qr.make(fit=True)  
	img = qr.make_image()
	return img

#        (\   /)                   
#     ﹏(0▽ 0 ) ﹏                 
#####^^^########^^^################
##        Queue  handler         ##
##########~..~#####################
#                                  
import Queue
queue = Queue.Queue()
def addItem(item):
	queue.put(item)
	
def getItem():
	try:
		item = queue.get(timeout = 2)
		return item
	except Queue.Empty:
		print 'queue empty'
		return None
	
def getQSize():
	return queue.qsize()
	
def clearQueue():
	queue.queue.clear()

##############################################################################
# Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ 
#   Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ Ƹ̵̡Ӝ̵̨̄Ʒ   
##############################################################################

if '__main__' == __name__:
	while(True):
		cType = raw_input("Input:")
		if cType == 'a':
			addItem("A")
		elif cType == 'g':
			print getItem()
		elif cType == 's':
			print getQSize()
		elif cType == 'c':
			clearQueue()
		else:
			break;
		pass






















