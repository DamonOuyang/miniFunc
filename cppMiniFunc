*****************************
* CPP
* std::move 语义
*****************************
#include <iostream>
#include <string.h>

using namespace std;

/*
 *1 move constructor  copy ocnstructor
 *
 *2 所谓的浅拷贝的时候，如果对象不包含type* 类型资源的时候。等位拷贝。
 *3 当涉及到，type * ,需要深拷贝，如果不深拷贝会出现什么问题。double free
 *4 move chonstructor 本质上是浅拷贝，所以他的应用场景，需要分析使用
 *
 * /

/**
 * @brief main
 * @param argc
 * @param argv
 * @return
 */
char * foo()
{
   char arr[100];
   return arr;
}
char* p = foo(); // 1 这样是不行的

char* foo2()
{
    char* arr = new char[100];
    return arr;
}
//char* p = foo2();// 2 这样是可以的

class A
{
public:
    A(int n=0):_n(n)
    {
         cout << "A()" << endl;
        _str = new char[_n];
    }
    A(const A & another)
    {
        cout << "copy resource" << endl;
        _str = new char[another._n];
        _n = another._n;
        memcpy(_str,another._str,another._n);
    }
    A(A && another)  // move constructor
    {
        cout << "move resource" << endl;
        this->_n = another._n;
        this->_str = another._str;
        another._str = nullptr;
    }

    ~A()
    {
        if( _str != nullptr)
        {
            cout << "~A()" << endl;
            delete [] _str;
            _str = nullptr;
        }

    }
public:
    char*_str;
    int _n;
};
A foo3()
{
    A a(10);
    strcpy(a._str,"china");
    return a;
}
// A a = foo3();
// 3 可以用，但白白拷贝了一次 先生成100个字节，函数返回的时候生产了临时变量也是100个字节
// 最后使用的时候，又拷贝了100个字节。

// 移动语义的本意：就是浅拷贝。
int main(int argc, char *argv[])
{
    A a = foo3();
    cout << "-------------" << endl;
    A a(100);
    A b(a);
    cout << "-------------" << endl;
    // 此处，本来应该调用 深拷贝，我通过std::move,将其变为了右值性质
    A c(std::move(a)); // “乾坤大挪移”“a 感觉被掏空”
    cout << "-------------" << endl;
    
    cout << a._str << endl;
    return 0;
}


*****************************
* CPP
* 移位操作 IC卡支付两个 实例
*****************************
void IrKeyFacade::handleIrKey(unsigned char* buf, int len)
{
	if(buf[1] == 0x09)
	{
		int balance = 0;
		//balance = buf[6]|(buf[7]<<8)|(buf[8]<<16)|(buf[9]<<24); // 移位操作 数组变为值
		memcpy(&balance, buf+6, 4);
		emit sign_status_pay(true, balance);
	{
}

void send_status_ZKTeco(int price,unsigned short framId)
{

        //printf("send_status_ZKTeco : %d\n" ,price);

        char cmd = 0xA2;

        const int dataLen = 4;
        unsigned char data[dataLen];
        data[0]=price>>24;  // 高位在前，值变为数组
        data[1]=price>>16;
        data[2]=price>>8;
        data[3]=price;

        cmdCreate_ZKTeco(cmd,framId,data,dataLen);
}

*****************************
* CPP
* 设计模式之单例模式 与 破解功能 实例
*****************************
#include <iostream>
using namespace std;
// 单例
class Singletion
{
public:
    static Singletion * getInstance() // 静态成员函数，用来管理静态函数
    {
        if(_instance == NULL)
        {
            _instance = new Singletion;
        }
        return _instance;
    }

    static void releaseInstance()
    {
        if(_instance != NULL)
        {
            delete _instance;
            _instance = NULL;
        }
    }

    Singletion* copy_single()
    {
        Singletion s ;
        Singletion ss(s);
        s = ss;
	
	//Singletion *s1 = new Singletion;
	//return s1;
	
        return &s;
    }

protected:
    Singletion(){}  // 构造器
    Singletion(const Singletion& other)=delete;// 拷贝构造器
   // Singletion(const Singletion& other){}// 拷贝构造器
    ~Singletion(){}  // 析造器
    //Singletion& operator=(const Singletion &other){}
    Singletion& operator=(const Singletion &other)=delete;
    // 赋值运算符重载,在这里不用理会，因为只能有两个对象才能发生

    static Singletion * _instance;

};

Singletion * Singletion::_instance = NULL;

int main(int argc, char *argv[])
{
    Singletion * s  = Singletion::getInstance();
//    Singletion s2 = Singletion(*s); // 测试 拷贝构造器
    Singletion *ss = s->copy_single();
    return 0;
}

*****************************
* CPP
* 设计模式之创建者模式 实例
*****************************
#include<stdio.h>
#include <stdlib.h>
#include <Windows.h>
//中文环境，英文环境
//屏幕，大小
void runtext(HWND win, char ch);
void setsizepose(HWND win, int x, int y);

void startnotepad(char ch, int x, int y)//ch='e' 'c' x,y
{
	system("start notepad");
	Sleep(3000);
	HWND win = FindWindowA("Notepad", "无标题 - 记事本");
	if (win==NULL)
	{
		printf("找不到哦啊");
	}
	runtext(win,ch);
	setsizepose(win, x, y);
}

void setsizepose(HWND win ,int x, int y)
{
	if (x>800 & y>600)
	{
		SetWindowPos(win, NULL, 0, 0, 800, 600, 0);
	} 
	else
	{
		SetWindowPos(win, NULL, 0, 0, 480, 320, 0);
	}
}

void runtext(HWND win,char ch)
{
	if (ch == 'e')
	{
		SetWindowTextA(win, "i love you ,money , girl");
	}
	else if (ch == 'j')
	{
		SetWindowTextA(win, "所噶，花姑娘的有");
	}
	else
	{
		SetWindowTextA(win, "我喜欢事业与爱情");
	}
}
void main()
{
	startnotepad('j', 1700, 1500);
	system("pause");
}
*****************************
* CPP
* 滑动窗口 实现实例
*****************************
#include <iostream>
#include <vector>
#include <deque>
using namespace std;
#define ROW_MAX_SIZE 500
#define COL_MAX_SIZE 500

class Solution {
public:
/**
* @param nums: A list of integers.
* @return: The maximum number inside the window at each moving.
*/
    vector<int> maxSlidingWindow(vector<int> &nums, int k)
    {
        // write your code here
        deque<int> q;
        vector<int> res;

        int sz = nums.size();
        // 1,5,7,7,3,2,8,0
        // 7,5,1
        // 0 1 2 3 4 5 6 7  i
        for(int i = 0; i < sz; i++)
        {
            while(q.size() && nums[q.back()] <= nums[i])
                q.pop_back();


            while(q.size() && q.front() <= i - k) // 处理刚开始的几个下标
                q.pop_front();

            q.push_back(i);

            if(i >= k - 1) // 队列中达到滑动窗口个数后，每循环一次，队列处理一次取一个
                res.push_back(nums[q.front()]);
        }
        return res;
    }
};

int main(int argc, char *argv[])
{
    vector<int> nums={1,5,7,7,3,2,8,0};
    Solution s;
    vector<int> res = s.maxSlidingWindow(nums,3); // 滑动窗口中取最大的
    for (int i;i<res.size();i++)
    {
        cout<<res[i] << " ";
    }
}
*****************************
* CPP
* auto_ptr 实现实例
*****************************
template<class T>
class auto_ptr {
public:
  explicit auto_ptr(T *p = 0); // Item M5 有“explicitfor”
                               // 的描述
template<class U>              // 拷贝构造函数成员模板
auto_ptr(auto_ptr<U>& rhs);    // （见 Item M28）：
                               // 用另一个类型兼容的
                               // auto_ptr 对象
                               // 初始化一个新的 auto_ptr 对象
~auto_ptr();

template<class U> // 赋值操作成员模板
auto_ptr<T>&       // （见 Item M28）：
operator=(auto_ptr<U>& rhs); // 用另一个类型兼容的
                             // auto_ptr 对象给它赋值
T& operator*() const; // 见 Item M28
T* operator->() const; // 见 Item M28
T* get() const; // 返回包容指针的
                // 当前值
T* release(); // 放弃包容指针的
// 所有权，
// 并返回其当前值
void reset(T *p = 0); // 删除包容指针，
// 获得指针 p 的所有权
private:
T *pointee;
template<class U> // 让所有的 auto_ptr 类
friend class auto_ptr<U>; // 成为友元
};
template<class T>
inline auto_ptr<T>::auto_ptr(T *p)
: pointee(p)
{}
template<class T>
inline auto_ptr<T>::auto_ptr(auto_ptr<U>& rhs)
: pointee(rhs.release())
{}
template<class T>
inline auto_ptr<T>::~auto_ptr()
{ delete pointee; }
template<class T>
template<class U>
inline auto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<U>& rhs)
{
if (this != &rhs) reset(rhs.release());
return *this;
}
template<class T>
inline T& auto_ptr<T>::operator*() const
{ return *pointee; }
template<class T>
inline T* auto_ptr<T>::operator->() const
{ return pointee; }
template<class T>
inline T* auto_ptr<T>::get() const
{ return pointee; }
template<class T>
inline T* auto_ptr<T>::release()
{
T *oldPointee = pointee;
pointee = 0;
return oldPointee;
}
template<class T>
inline void auto_ptr<T>::reset(T *p)
{
if (pointee != p) {
delete pointee;
pointee = p;
}
}

*****************************
* CPP
* reference class realize
*****************************
template<class T>
class RCPtr
{
public:
  RCPtr(T* realPtr = 0);
  RCPtr(const TRCtr& rhs);
  ~RCPtr();
  RCTtr& operator=(const RCPtr& rhs);
  T* operator-> () const;
  T& operator* () const;
  
private:
  T * pointee;
  void init();
};

class RCObject
{
public:
  void addReference();
  void removeReference();
  void markUnshareable();
  bool isShareable() const;
  bool isShared() const;
protected:
  RCObject();
  RCObject(const RCObject$ rhs);
  RCObject& operator= (const RCObject& rhs);
  virtual ~RCObject() = 0;
private:  
  int refCount;
  bool shareable;
};

class String 
{
public:
  String(const char* value = "");
  const char& operator[] (int index ) const;
  char& operator[] (int index);
private:
  // class representing string values
  struct StringValue: public RCObject
  {
    char*data;
    StringValue(const char* initValue);
    StringValue(const StringValue& rhs);
    void init(const char* initValue);
    ~StringValue();
  };
  RCPtr<StringValue> value;
};

RCObject::RCObject()
  : refCount(0), shareable(true)
  {}
  
RCObject::RCObject(const RCObject&)
  : refCount(0), shareable(true) 
  {}
  
RCObject& RCObject::operator= (const RCObject&)
  { return *this; }
  
RCObject::~RCObject() 
  {}

void RCObject::addReference() 
  { ++refCount; }
  
void RCObject::removeReference()
  { if (--refCount == 0) delete this; }
  
void RCObject::markUnshareable()
  { shareable = false; }
  
bool RCObject::isShareable() const
  { return shareable; }
  
bool RCObject::isShared() const
  { return refCount > 1; }
  
这是 RCPtr 的实现：
template<class T>
void RCPtr<T>::init()
{
  if (pointee == 0) return;
  if (pointee->isShareable() == false) 
  {
    pointee = new T(*pointee);
  }
  pointee->addReference();
}

template<class T>
RCPtr<T>::RCPtr(T* realPtr)
  : pointee(realPtr)
    { init(); }
    
template<class T>
RCPtr<T>::RCPtr(const RCPtr& rhs)
  : pointee(rhs.pointee)
  { init(); }

template<class T>
RCPtr<T>::~RCPtr()
  { if (pointee)pointee->removeReference(); }

template<class T>
RCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)
{
  if (pointee != rhs.pointee) 
  {
    if (pointee) pointee->removeReference();
    pointee = rhs.pointee;
    init();
  }
  return *this;
}

template<class T>
T* RCPtr<T>::operator->() const 
  { return pointee; }

template<class T>
T& RCPtr<T>::operator*() const 
  { return *pointee; }

这是 String::StringValue 的实现：
void String::StringValue::init(const char *initValue)
{
  data = new char[strlen(initValue) + 1];
  strcpy(data, initValue);
}

String::StringValue::StringValue(const char *initValue)
  { init(initValue); }

String::StringValue::StringValue(const StringValue& rhs)
  { init(rhs.data); }

String::StringValue::~StringValue()
  { delete [] data; }

最后，归结到 String，它的实现是：
String::String(const char *initValue)
  : value(new StringValue(initValue)) 
  {}

const char& String::operator[](int index) const
  { return value->data[index]; }

char& String::operator[](int index)
{
  if (value->isShared()) 
  {
    value = new StringValue(value->data);
  }
  value->markUnshareable();
  return value->data[index];
}










